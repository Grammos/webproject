package shapp.odk.org.shapp;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.StrictMode;
import android.util.Log;
import android.view.View;
import android.view.ViewGroup;
import android.widget.AdapterView;
import android.widget.BaseAdapter;
import android.widget.GridView;


import com.squareup.picasso.Picasso;

import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;


import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.HttpURLConnection;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;


public class MainScreen extends Activity
{

    @Override
    protected void onCreate(Bundle savedInstanceState)
    {
        super.onCreate(savedInstanceState);

        setContentView(R.layout.activity_main_screen);

        GridView gridView = (GridView)findViewById(R.id.gridview);
        // Create the Custom Adapter Object
        MainScreenAdapter mainScreenAdapter = new MainScreenAdapter(this);
        // Set the Adapter to GridView
        gridView.setAdapter(mainScreenAdapter);


        // Handling touch/click Event on GridView Item

        /**Interface definition for a callback to be invoked when an item in this AdapterView has been clicked.
         * please read more at http://developer.android.com/reference/android/widget/AdapterView.OnItemClickListener.html
         */
        gridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {

            @Override
            public void onItemClick(AdapterView<?> adapterView, View view, int i, long id) {

                switch(i){

                    /*
                     * An Intent provides a facility for performing late runtime binding between the code in different applications.
                     * Its most significant use is in the launching of activities, where it can be thought of as the glue between activities.
                     * It is basically a passive data structure holding an abstract description of an action to be performed.
                     * please read more at http://developer.android.com/reference/android/content/Intent.html
                     *
                     *
                     * method getApplicationContext():
                     *  Return the context of the single, global Application object of the current process.
                     *
                     * I've used switch because I know that this screen for a long time will have the same
                     * content so it's something predefined. :)!
                   */
                    case 0:
                        Intent reportButton = new Intent(getApplicationContext(), Report.class);
                        startActivity(reportButton);
                        //Log.d("REPORT ","BUTTON "+ reportButton);
                        break;

                    case 1:
                        Intent lightButton = new Intent(getApplicationContext(), Light.class );
                        startActivity(lightButton);
                        //Log.d("LIGHT ", "BUTTON " + lightButton);
                        break;

                    case 2:
                        Intent mapsButton = new Intent(getApplicationContext(), Maps.class );
                        startActivity(mapsButton);
                        //Log.d("MAPS ", "BUTTON " + mapsButton);
                        break;

                    case 3:
                        Intent analyticsButton = new Intent(getApplicationContext(), Analytics.class );
                        startActivity(analyticsButton);
                        //Log.d("ANALYTICS ", "BUTTON " + analyticsButton);
                        break;

                    case 4:
                        Intent settingsButton = new Intent(getApplicationContext(), Settings.class );
                        startActivity(settingsButton);
                        //Log.d("SETTINGS ", "BUTTON " + settingsButton);
                        break;

                    case 5:
                        Intent contactButton = new Intent(getApplicationContext(), Contact.class );
                        startActivity(contactButton);
                        //Log.d("CONTACT ", "BUTTON" + contactButton);
                        break;
                }
            }
        });
    }


    /*
    * What is a Adapter?
    * An Adapter object acts as a bridge between an AdapterView and the underlying data for that view.
    * The Adapter provides access to the data items.
    * The Adapter is also responsible for making a View for each item in the data set.
    * What is a BaseAdapter?
    * BaseAdapter is an abstract base class for the Adapter interface to simplify implementing adapters.
    * You could implement your own, but the framework provides some pretty flexible adapters already.
    * Some popular adapters are:
    * ArrayAdapter,CursorAdapter, SimpleCursorAdapter. Please read more at this awesome comment:
    * (first one)
    * http://stackoverflow.com/questions/4799380/understanding-baseadapters-and-how-to-use-them
    *
    * */

    private class MainScreenAdapter extends BaseAdapter
    {
        /* //Just some basics explanation for why i used final..
        *    static means "not related to a particular instance at all" - final means you cannot change this value after
        initialization
        *       and this value must be initialized.
        *   The combination of final and static gives you the ability to create constants. This is no longer recommended in a public way
        *   (totally ok for e.g. magic numbers in a private context) as it's not type safe.
        *
        *
        *  What is a Context?
        *  As the name suggests, its the context of current state of the application/object. It lets newly created objects understand what has been going on.
        *  Typically you call it to get information regarding another part of your program (activity, package/application)
        *  please read more: http://stackoverflow.com/questions/3572463/what-is-context-in-android (first and second comments :)!
        * */


        private final Context contextMain;
        private final List<String> urlsButtonPics = new ArrayList<>();

        public MainScreenAdapter(Context contextMain)
        {
            this.contextMain = contextMain;
            

            try {

                //it's not a good choice i don't want to cheat on the "network" UI of the thread
                /*
                * StrictMode is a developer tool which detects things you might be doing by accident and brings them
                * to your attention so you can fix them.
                * Please read more at: http://developer.android.com/reference/android/os/StrictMode.html
                *
                *
                    java.lang.Object
                                    â†³	android.os.StrictMode.ThreadPolicy.Builder
                *Creates StrictMode.ThreadPolicy instances. Methods whose names start with detect specify what problems we should look for.
                * Methods whose names start with penalty specify what we should do when we detect a problem.
                * // read more at: http://developer.android.com/reference/android/os/StrictMode.ThreadPolicy.Builder.html
                *
                * */
                if (android.os.Build.VERSION.SDK_INT > 9) {
                    StrictMode.ThreadPolicy policy =
                            new StrictMode.ThreadPolicy.Builder().permitAll().build();
                    StrictMode.setThreadPolicy(policy);
                }

                /**please read more for the usage of URL at:
                * http://developer.android.com/reference/java/net/URL.html#getRef()*/
                URL urlHarassmentApi = new URL("http://10.0.2.2:5000/geo-api");

                /*
                *   http://developer.android.com/reference/java/net/HttpURLConnection.html
                *   An URLConnection for HTTP (RFC 2616) used to send and receive data over the web. Data may be of any type and length.
                *   This class may be used to send and receive streaming data whose length is not known in advance.
                * */
                HttpURLConnection connMain = (HttpURLConnection)urlHarassmentApi.openConnection();

                //add request header
                /**
                 * By default, this implementation of HttpURLConnection requests that servers use gzip compression.
                 * Since getContentLength() returns the number of bytes transmitted, you cannot use that method to predict
                 * how many bytes can be read from getInputStream(). Instead, read that stream until it is exhausted: when read() returns -1.
                 * Gzip compression can be disabled by setting the acceptable encodings in the request header:
                 */
                connMain.setRequestProperty("Accept", "application/json");
                connMain.setRequestMethod("GET");

                // this condition is to check the request response from the API, this will deal with
                //the files that are been saved in API..
                if (connMain.getResponseCode() != 200) {
                    throw new RuntimeException("Failed : HTTP error code : "
                            + connMain.getResponseCode());
                }

                /*
                * Wraps an existing Reader and buffers the input.
                *
                *InputStreamReader:
                * A class for turning a byte stream into a character stream.
                * Data read from the source input stream is converted into characters by
                * either a default or a provided character converter.
                * http://developer.android.com/reference/java/io/InputStreamReader.html
                *
                * getInputStream()
                * Returns an InputStream for reading data from the resource pointed by the URLConnection.
                * */
                BufferedReader reader = new BufferedReader(
                        new InputStreamReader(connMain.getInputStream()));

                /*StringBuilder:
                This class is mainly used to interact with legacy APIs that expose it.
                * http://developer.android.com/reference/java/lang/StringBuilder.html
                * */
                StringBuilder response = new StringBuilder();

                String inputLine;
                /**readLine()Returns the next line of text available from this reader.
                 *
                 * */
                while ((inputLine = reader.readLine()) != null) {
                    response.append(inputLine);
                /**append(String str)
                    Appends the contents of the specified string.*/
                }

                // Closes this reader
                reader.close();


                /*OutputStreamWriter:
                A class for turning a character stream into a byte stream.
                Data written to the target input stream is converted into bytes by either a
                default or a provided character converter.
                *
                * */


                    try {
                        OutputStreamWriter outputStreamWriter = new OutputStreamWriter(openFileOutput("config.json", Context.MODE_PRIVATE));
                        outputStreamWriter.write(response.toString());
                        outputStreamWriter.close();
                    }
                    catch (IOException e) {
                        Log.e("Exception", "File write failed: " + e.toString());
                    }




                    String ret = "";

                    try {
                        InputStream inputStream = openFileInput("config.json");

                        if ( inputStream != null ) {
                            InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
                            BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
                            String receiveString = "";
                            StringBuilder stringBuilder = new StringBuilder();

                            while ( (receiveString = bufferedReader.readLine()) != null ) {
                                stringBuilder.append(receiveString);
                            }

                            inputStream.close();
                            ret = stringBuilder.toString();
                        }
                    }
                    catch (FileNotFoundException e) {
                        Log.e("login activity", "File not found: " + e.toString());
                    } catch (IOException e) {
                        Log.e("login activity", "Can not read file: " + e.toString());
                    }



                JSONObject harassmentJsonArray = new JSONObject(ret);
                JSONArray harassmentJsonTypes = new JSONArray(harassmentJsonArray.getJSONObject("main_screen").getJSONArray("types").toString()) ;

                for (int i = 0; i < harassmentJsonTypes.length(); i++) {

                    JSONObject harassment = harassmentJsonTypes.getJSONObject(i);
                    String imageUrl = harassment.getString("imageUrl");
                    String harassmentName =  harassment.getString("name");
                    String harassmentId = harassment.getString("id");

                    urlsButtonPics.add(imageUrl);

                }



            } catch (IOException | JSONException e) {
                e.printStackTrace();
            }

        }


        @Override
        public int getCount() {
            return urlsButtonPics.size();
        }

        @Override
        public String getItem(int position) {
            return urlsButtonPics.get(position);
        }

        @Override
        public long getItemId(int position) {
            return position;
        }

        @Override
        public View getView(int position, View convertView, ViewGroup parent) {

            CircledImageView view = (CircledImageView) convertView;
            if (view == null) {
                view = new CircledImageView(contextMain);

            }

            // Get the image URL for the current position.
            String url = getItem(position);

            // Trigger the download of the URL asynchronously into the image view.
            Picasso.with(contextMain) //
                    .load(url) //
                    .placeholder(R.drawable.tree1) //
                    .error(R.drawable.tree2) //
                    .fit() //
                    .tag(contextMain) //
                    .into(view);

            return view;
        }


    }


}
